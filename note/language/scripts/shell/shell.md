# 目录
- [Shebang](#Shebang)
- [变量](#变量)
- [特殊变量](#特殊变量)
- [shell执行方式](#shell执行方式)
- [字符串](#字符串)

# Shebang
Linux中国翻译组的GOLinux将其翻译为`释伴`，也就是解释伴随行的简称，同时也是Shebang的音译

那么这个到底是个啥？其实就是写shell脚本时我们一般写在第一行的那个`#!/bin/bash`，当然不一定是bash，只是指向了该脚本的解释器，如果不通过文件第一行的Shebang指定解释器，则默认使用当前`$SHELL`环境变量。

# 变量
定义方式：变量名=值

> * 命名只能使用英文字母，数字和下划线，首个字符必须以字母开头。
> * 等号两边不能有空格
> * 变量名中间不能有空格，可以使用下划线`_`
> * 不能用标点符号
> * 注意不要和[bash自带的关键字](http://blog.chinaunix.net/uid-25880122-id-2941630.html)冲突，推荐用大写

变量使用：`$变量名`表示变量值
> - 在使用时为了避免出现边界判断错误导致使用到错误的变量，应该使用`{}`将变量名进行包裹
> - 除了上述的显示定义赋值以外，还可以用语句来实现，常见的为`for var in ${ls /etc}`

只读变量：readonly 变量名

删除变量：unset 变量名
> tips：`unset`不能删除只读变量

变量类型
1. 局部变量：只在当前函数有效  
```bash
#!/bin/bash
# 定义函数，函数中定义局部变量，以local修饰
function func(){
    local var=99
}
# 调用函数
func
# 输出之前的局部变量，为空
echo ${var}
```

2. 全局变量：在当前shell进程中有效
> shell默认创建的变量就是局部变量

3. 环境变量：可以在子shell中使用
> 使用export导出，但是要注意的是，只在同一个进程或者其后代进程中有效

# 特殊变量
| 变量 | 作用 |
|:-----:|:-----:|
| $0 | 当前文件 |
| $n(n >= 0) | 传递给脚本或函数的第几个参数 |
| $# | 传递给脚本的参数的个数 |
| $* | 传递给脚本的所有参数 |
| $@ | 传递给脚本的所有参数 |
| $? | 上一条命令的退出状态或者函数返回值 |
| $$ | 当前进程的进程号 |

> `$*`和`$@`作用基本相似, 但是在有一种情况下是不同的. 当使用`""`括起来的时候, 他们表示的内容有一定的区别

```bash
#!/bin/bash
for var in "$*"
do
    echo ${var}
done
echo 
for var in "$@"
do
    echo ${var}
done
```
执行结果如下:
```
$ ./a.sh aa ab ac ad
aa ab ac ad

aa
ab
ac
ad

```

# shell执行方式
shell脚本执行方案如下：  
1. 按照常规的可执行文件的执行方式执行
```
chmod +x test.sh
./test.sh
```
2. 将脚本作为参数传递给shell解释器
> 使用该方法后, 将会忽视掉Shebang的设置, 直接使用指定的解释器
3. 在当前的进程中运行脚本
> 本质相当于是在当前shell中将脚本内容一条一条的读出并执行, 这样自然就是在同一个进程中了, 使用方法如下:
```
source test.sh
. test.sh
```

# 字符串
