## 序言
我们在c++程序中，当我们需要管理内存的时候，几乎不可避免的会用到两个关键字：
`new`, `delete`。

## 原理是什么
那么`new`和`delete`又是怎么样实现的呢？以`new`为例，其作用大致可以划分如下：
1. 分配内存
2. 按照类型初始化
3. 返回分配的内存地址

对于内存的分配，则是通过使用`operator new`来实现的，是`new`文件中的全局实现。  
对于类型初始化，则是通过使用对应类型的构造函数来实现的，也是全局实现。  
那么`delete`也是相同的，只不过是先析构释放类型，然后在释放内存。

## operator xxx
如上所说，调用`new`或者`delete`的时候其实是用的`operator xxx`，看到`operator`
第一反应是重载，是的，这是可以重载的函数，不过需要注意的是`new`和`delete`的重载
需要匹配，不能只重载其中之一。但并不绝对，有一个特殊的重载: `placement new`。

## placement new
什么是`placement new`：如第二小节所言，`new`其实是做了三件事的，其中初始化操作
通过调用构造函数去初始化，如果我们已经拥有现成的内存空间了，这时候没必要在使用
常规的`new`去执行了，但在这种情况下构造函数不能显示调用，于是`placement new`就被
出来了，它只做一件事，就是调用构造函数。那么，问题来了，怎么去析构呢？是的，手动析构，
应为析构函数是可以显示调用的，而且只需要一条语句，也不需要封装。